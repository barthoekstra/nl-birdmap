---
title: "Netherlands Bird Migration Map"
subtitle: "Based on weather radar measurements"
author: Bart Hoekstra
#output: html_notebook
---

```{r setup, message=FALSE, warning=TRUE, include=FALSE}
library(tidyverse)
library(bioRad)
library(suncalc)
library(terra)
library(tidyterra)
library(raster)
library(sf)
library(stars)
library(parallel)
library(ggdark)
library(ggblend)
library(spatialEco)
library(fields)
library(ggnewscale)
library(colorspace)
library(ggspatial)
library(ggpattern)
library(ggfx)
library(gghalves)
library(pbmcapply)
library(legendry)
options(ggpattern_use_R4.1_masks = TRUE)
```

# Gathering data from peak nights
## Identifying peak nights
We start with loading a dataset containing cumulative passage metrics for day and night across Dutch weather radars, both seasons and all years.

```{r}
vp_mtr <- read_csv("data/vp_mtr_ordered_seasonal_day_night_migration.csv",
  col_types = cols(
    date_trunc = col_datetime(), odim_code = col_character(), year_season = col_character(), year = col_double(),
    season = col_character(), day_night = col_character(), slope_max = col_double(), slope_max_time = col_datetime(),
    mtr = col_double(), prop = col_double(), mtr_cum = col_double(), prop_cum = col_double(), top = col_double()
  )
) %>% 
  filter(day_night == "night")

head(vp_mtr %>% dplyr::select(date_trunc, odim_code, year, season, prop_cum, top), 10)
```
The dataset is sorted from largest night to smalles night in terms of cumulative passage, so we can select the peak nights that capture 50% of migration by selecting all nights that cumulatively have selected less and then the first night that pushes it above 50%.

```{r}
vp_mtr_cum50 <- vp_mtr %>%
  filter(prop_cum < 0.5 | (lag(prop_cum) < 0.5 & prop_cum >= 0.5))

vp_mtr_cum50
```

Now that we have identified the nights, we can calculate the moment of sunset, to find the polar volume scan closest to 2.5hrs after sunset.

```{r}
calculate_scantime <- function(r) {
  if (r["odim_code"] == "nlhrw") {
    lat <- 51.8371
    lon <- 5.138
  }
  if (r["odim_code"] == "nldhl") {
    lat <- 52.9528
    lon <- 4.79061
  }

  if (r["day_night"] == "daylight") {
    scantime <- suncalc::getSunlightTimes(lat = lat, lon = lon, date = as.Date(r["date_trunc"]), keep = "sunrise")
    scantime <- scantime$sunrise + hours(2)
  }
  if (r["day_night"] == "night") {
    scantime <- suncalc::getSunlightTimes(lat = lat, lon = lon, date = as.Date(r["date_trunc"]) - 1, keep = "sunset")
    scantime <- scantime$sunset + hours(2) + minutes(30)
  }

  scantime <- round_date(scantime, "5 mins")
}

scantimes <- as_datetime(unlist(apply(vp_mtr_cum50, MARGIN = 1, FUN = calculate_scantime, simplify = FALSE)))

vp_mtr_cum50$moment <- scantimes
vp_mtr_cum50
```
## Download peak time scans
From the `moment` column in the `vp_mtr_cum50` dataframe, one can distill which pvol files have to be downloaded from the KNMI weather radar repository. At the UvA, we host those publicly available datasets locally on a private [minio](https://min.io) S3 server, but others can download the polar volume files from the KNMI directly: [Herwijnen](https://dataplatform.knmi.nl/dataset/radar-tar-vol-full-herwijnen-1-0) and [Den Helder](https://dataplatform.knmi.nl/dataset/radar-tar-volume-denhelder-1-0) after [registering](https://developer.dataplatform.knmi.nl) for a free API key.

```{r eval=FALSE, include=FALSE}
# minio/pvol/NL/HRW/2016/08/31/NLHRW_pvol_20160831T2350_6356.h5
dts <- dplyr::select(vp_mtr_cum50, odim_code, moment)

dts_hrw <- dts %>%
  filter(odim_code == "nlhrw") %>%
  pull(moment)

filepaths_hrw <- paste0(
  "minio/pvol/NL/HRW/", year(dts_hrw), "/", sprintf("%02d", month(dts_hrw)), "/", sprintf("%02d", day(dts_hrw)), "/",
  "NLHRW_pvol_", format(dts_hrw, format = "%Y%m%dT%H%M"), "_6356.h5"
)
filepaths_hrw_alt <- paste0(
  "minio/pvol/NL/HRW/", year(dts_hrw), "/", sprintf("%02d", month(dts_hrw)), "/", sprintf("%02d", day(dts_hrw)), "/",
  "NLHRW_pvol_", format(dts_hrw, format = "%Y%m%dT%H%M"), "_NL52.h5"
)
paths <- list(paste0("mc cp ", filepaths_hrw, " ."), paste0("mc cp ", filepaths_hrw_alt, " ."))

write_lines(unlist(paths), file = "data/pvol/hrw_files.sh", )

dts_dhl <- dts %>%
  filter(odim_code == "nldhl") %>%
  pull(moment)

filepaths_dhl <- paste0(
  "minio/pvol/NL/DHL/", year(dts_dhl), "/", sprintf("%02d", month(dts_dhl)), "/", sprintf("%02d", day(dts_dhl)), "/",
  "NLDHL_pvol_", format(dts_dhl, format = "%Y%m%dT%H%M"), "_6234.h5"
)
filepaths_dhl_alt <- paste0(
  "minio/pvol/NL/DHL/", year(dts_dhl), "/", sprintf("%02d", month(dts_dhl)), "/", sprintf("%02d", day(dts_dhl)), "/",
  "NLDHL_pvol_", format(dts_dhl, format = "%Y%m%dT%H%M"), "_NL51.h5"
)
paths <- list(paste0("mc cp ", filepaths_dhl, " ."), paste0("mc cp ", filepaths_dhl_alt, " ."))

write_lines(unlist(paths), file = "data/pvol/dhl_files.sh", )
```

```{r eval=FALSE, include=FALSE}
downloaded_files <- list.files("data/pvol", full.names = TRUE)
downloaded_files <- downloaded_files[!downloaded_files %in% c("data/pvol/dhl_files.sh", "data/pvol/hrw_files.sh")]
downloaded_files_hrw <- downloaded_files[str_detect(downloaded_files, "NLHRW")]
downloaded_files_dhl <- downloaded_files[str_detect(downloaded_files, "NLDHL")]

downloaded_files_dhl_dts <- as_datetime(unlist(
  lapply(downloaded_files_dhl, function(x) parse_date_time(str_split(x, "_")[[1]][3], "YmdHM"))
))
downloaded_files_hrw_dts <- as_datetime(unlist(
  lapply(downloaded_files_hrw, function(x) parse_date_time(str_split(x, "_")[[1]][3], "YmdHM"))
))

downloaded_dts_dhl <- data.frame(pvolfile = downloaded_files_dhl, moment = downloaded_files_dhl_dts)
downloaded_dts_dhl$odim_code <- "nldhl"
downloaded_dts_hrw <- data.frame(pvolfile = downloaded_files_hrw, moment = downloaded_files_hrw_dts)
downloaded_dts_hrw$odim_code <- "nlhrw"
downloaded_dts <- bind_rows(downloaded_dts_dhl, downloaded_dts_hrw)

vp_mtr_cum50 %>%
  left_join(downloaded_dts, by = join_by(odim_code == odim_code, moment == moment)) %>%
  drop_na() -> vp_mtr_cum50
```

# Process RBCs for bird density maps
The pipeline used to convert the polar volume scans to range-bias corrected PPIs that we can incorporate in our bird migration maps, is self-contained in the `rbc_preprocessing.R` file.

## RBC selection
After processing the RBCs, there is a folder `data/rbc_png/full` that contains .png's with several diagnostic plots of the processed RBCs. These have to be manually screened for clutter from rain and anomalous propagation and files should be moved to the subfolders `Accepted` if the scans are clean examples of bird migration and `Rejected` if they aren't.

## Selected usable scans
We now add the outcome of the screening procedure to the dataframe containing an overview of our data.

```{r}
accepted_files <- list.files("data/rbc_png/full/Accepted/")
rejected_files <- list.files("data/rbc_png/full/Rejected/")

rbc_file_from_png <- function(file, azim_method = "full") {
  f <- basename(file)
  ss <- str_split(f, "_")[[1]][1:4]
  radar <- str_to_lower(ss[1])
  moment <- parse_date_time(ss[3], "YmdHM")
  fp <- paste0("data/rbc/", str_c(ss, collapse = "_"), "_", azim_method, ".RDS")
  return(list("odim_code" = radar, "moment" = moment, "rbcfile" = fp))
}

accepted <- bind_rows(lapply(accepted_files, rbc_file_from_png)) %>% mutate(status = "Accepted")
rejected <- bind_rows(lapply(rejected_files, rbc_file_from_png)) %>% mutate(status = "Rejected")

classified_moments <- bind_rows(accepted, rejected)

vp_mtr_cum50 %>%
  left_join(classified_moments, by = join_by(odim_code, moment)) %>%
  mutate(status = replace_na(status, "Rejected")) %>%
  drop_na() %>%
  identity() -> vp_mtr_cum50_cl
```

## Seasonal proportion of migration covered

Having screened the scans now, we can see what proportion of seasonal migration is captured in the clean scans.

```{r message=FALSE}
vp_mtr_cum50_cl %>%
  filter(status == "Accepted") %>%
  group_by(year, season, odim_code, day_night) %>%
  summarise(total_prop = sum(prop)) %>%
  mutate(
    season_date = case_when(
      season == "spring" ~ as.Date(paste(year, "03-15", sep = "-")),
      season == "autumn" ~ as.Date(paste(year, "09-15", sep = "-")),
      TRUE ~ NA_Date_
    ),
    radar_nice = case_when(
      odim_code == "nlhrw" ~ "Herwijnen",
      odim_code == "nldhl" ~ "Den Helder"
    ),
    day_night = case_when(
      day_night == "daylight" ~ "day",
      day_night == "night" ~ "night",
    ),
    day_night_nice = case_when(
      day_night == "day" ~ "Day",
      day_night == "night" ~ "Night"
    )
  ) %>%
  ungroup() %>%
  identity() -> sp

sp %>%
  group_by(odim_code, radar_nice) %>%
  summarise(
    mean_prop = mean(total_prop),
    min_prop = min(total_prop),
    max_prop = max(total_prop)
  ) %>%
  ungroup() -> sp_summary

sp_summary

sp %>%
  group_by(season) %>%
  summarise(
    mean_prop = mean(total_prop),
    min_prop = min(total_prop),
    max_prop = max(total_prop)
  ) %>%
  ungroup() -> sp_summary_seasonal

sp_summary_seasonal
```

```{r}
# Define the moon and sun symbols using Unicode
sp %>%
  mutate(total_prop = total_prop * 100) %>%
  ggplot() +
  geom_point(aes(x = season_date, y = total_prop, color = total_prop)) +
  geom_hline(data = sp_summary, aes(yintercept = mean_prop * 100), linetype = "dashed", color = "black") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  facet_wrap(vars(radar_nice)) +
  xlab("Season") +
  ylab("% of migration mapped") +
  labs(title = "Seasonal proportion of migration included in map", color = "% of migration")

ggsave("data/plots/seasonal_props.pdf", width = 10, height = 6)
```

## Process scans to season-year stacks
With all RBCs processed and all clean migration moments gathered, we can create stacks of season-year combinations (e.g. autumn 2017, autumn 2018, spring 2019, spring 2021). We store all the individual RBCs' VIR parameters as individual layers and average them to a layer called `VIR` (and some transformations like `VIR_sqrt` and `VIR_log10`. While creating the stacks, we filter out areas where the RBC matches the following conditions:

1. `VIR` is above `2500`
2. `VIR` is exactly `0` (the pixel has never reflected)
3. There is rain in one of the elevation scans above the pixel
4. The adjustment factor `R` is above `10`.

```{r}
stack_rbcs <- function(rbcs, year_season, odimcode, daytime = "night", threshold_max = 2500, mean_method = "scans", 
                       R_threshold = NULL, overwrite = FALSE, clutter_map = FALSE) {
  # See if files exist already
  if (is.null(R_threshold)) {
    R_text <- "null"
  } else {
    R_text <- R_threshold
  }

  basepath <- "data/stacks/"
  if (clutter_map) {
    basepath <- "data/stacks_clutter/"
  }
  
  filepath <- paste0(
    basepath,
    str_to_upper(odimcode), "_", year_season, "_thresh_", threshold_max, "_avg_", mean_method, "_", daytime, "_", R_text, ".RDS"
  )
  rasterpath <- paste0(
    basepath,
    str_to_upper(odimcode), "_", year_season, "_thresh_", threshold_max, "_avg_", mean_method, "_", daytime, "_", R_text, ".tif"
  )

  if (file.exists(filepath) && file.exists(rasterpath)) {
    if (!overwrite) {
      return("exists")
    }
  }

  r <- rbcs[[1]]
  rp <- r

  VIRs <- list()
  CLUTs <- list()

  for (i in seq_along(rbcs)) {
    VIR <- rbcs[[i]]$data@data$VIR
    CLUT <- rbcs[[i]]$data@data$VIR * 0
    R <- rbcs[[i]]$data@data$R
    RAIN <- rbcs[[i]]$data@data$rain
    # if (!clutter_map) {
    clutlocs <- which(VIR > threshold_max)
    VIR[clutlocs] <- NA
    CLUT[clutlocs] <- CLUT[clutlocs] + 1
    # } else {
    #   VIR[which(VIR > threshold_max)] <- threshold_max
    # }
    VIR[which(VIR == 0)] <- NA
    rainlocs <- which(RAIN > 0)
    # VIR[rainlocs] <- NA
    # CLUT[rainlocs] <- CLUT[rainlocs] + 1
    if (!is.null(R_threshold) && !clutter_map) {
      r_thresh_locs <- which(R_threshold > 10)
      VIR[r_thresh_locs] <- NA
      CLUT[r_thresh_locs] <- CLUT[r_thresh_locs] + 1
    }
    VIRs <- append(VIRs, list(VIR))
    CLUTs <- append(CLUTs, list(CLUT))
  }

  mVIR <- do.call(rbind, VIRs)
  mVIR[is.na(mVIR)] <- 0
  VIR_summed <- mVIR[1, ] * 0
  
  mCLUT <- do.call(rbind, CLUTs)
  CLUT_summed <- colSums(mCLUT)

  for (j in seq_along(VIRs)) {
    if (j == 1) {
      VIR_summed <- as.vector(as.matrix(mVIR[1:j, ]))
      rp$data@data[paste0("VIR_", j)] <- VIR_summed
      next
    }

    VIR_summed <- colSums(as.matrix(mVIR[1:j, ])) / j
    rp$data@data[paste0("VIR_", j)] <- as.numeric(VIR_summed)
  }

  remove_variables <- c("VID", "R", "overlap", "eta_sum", "eta_sum_expected", "rain")
  for (var in remove_variables) {
    rp$data@data[var] <- NULL
  }
  rp$data$VIR <- as.vector(as.matrix(rp$data@data[paste0("VIR_", length(VIRs))]))
  rp$data$CLUT <- as.numeric(CLUT_summed)

  rp <- calculate_param(rp, VIR_log10 = log10(VIR), VIR_log = log(VIR), VIR_sqrt = sqrt(VIR))
  saveRDS(rp, filepath)
  rrast <- terra::rast(rp$data)
  fixedlayers <- c("VIR", "VIR_log10", "VIR_log", "VIR_sqrt")
  layernames <- names(rrast)
  layerorder <- c(which(layernames %in% fixedlayers), which(!layernames %in% fixedlayers))
  rrast <- subset(rrast, layerorder)
  rf <- terra::writeRaster(rrast, rasterpath, overwrite = overwrite)
  return(filepath)
}

g <- expand.grid(
  year_season = unique(vp_mtr_cum50_cl$year_season),
  day_night = unique(vp_mtr_cum50_cl$day_night),
  odim_code = unique(vp_mtr_cum50_cl$odim_code)
)

generate_stacks <- function(year_season, day_night, odim_code,
                            # th = c(500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000),
                            th = 2500,
                            R_threshold = 10,
                            overwrite = FALSE) {
  vp_mtr_cum50_cl %>%
    filter(status == "Accepted", year_season == !!year_season, day_night == !!day_night, odim_code == !!odim_code) %>%
    drop_na() %>%
    arrange(top) %>%
    dplyr::select(rbcfile, prop) -> files

  if (nrow(files) == 0) {
    return("files do not exist")
  }

  gr <- expand.grid(th = th, R_threshold = R_threshold, stringsAsFactors = FALSE)
  gr <- asplit(gr, 1)

  rbcs <- lapply(files$rbcfile, readRDS)
  lapply(gr, function(x) {
    stack_rbcs(
      rbcs = rbcs, year_season = year_season, odimcode = odim_code,
      threshold_max = as.numeric(x["th"]), R_threshold = as.numeric(x["R_threshold"]), overwrite = overwrite
    )
  })
}

processing_stacking <- pbmcmapply(generate_stacks,
  year_season = g$year_season, day_night = g$day_night, odim_code = g$odim_code,
  overwrite = TRUE, mc.cores = 6, mc.preschedule = FALSE
)
saveRDS(processing_stacking, paste0("data/logs/processing_stacking_", format(Sys.time(), "%Y%m%dT%H%M"), ".RDS"))
```

## Combine season stacks to radar, period stacks
Now we can continue simply creating averages of the season-year stacks, resulting in rasters of average `VIR` per season per radar. We also limit the domain of the stacks to 100km from the radar now.

```{r}
final_stacks <- expand.grid(
  odim_code = c("NLHRW", "NLDHL"),
  season = c("spring", "autumn"),
  daytime = c("night"),
  th = 2500,
  mm = c("scans"),
  R_threshold = 10
)

for (i in 1:nrow(final_stacks)) {
  fs <- final_stacks[i, ]

  rastfiles <- Sys.glob(
    paste0("data/stacks/", str_to_upper(fs$odim_code), "_*_", fs$season, "_thresh_", fs$th, "_avg_", fs$mm, "_", fs$daytime, "_", fs$R_threshold, ".tif")
  )

  stk <- terra::rast(lapply(rastfiles, function(x) {
    tryCatch(terra::rast(x, lyrs = "VIR"),
      error = function(err) {
        print(err)
      }
    )
  }))
  rmean <- app(stk, mean)
  names(rmean) <- "vir_mean"
  
  stk <- terra::rast(lapply(rastfiles, function(x) {
    tryCatch(terra::rast(x, lyrs = "CLUT"),
      error = function(err) {
        print(err)
      }
    )
  }))
  csum <- app(stk, sum)
  csum <- csum / minmax(csum)[2]
  names(csum) <- "clut_sum"

  file_out <- paste0(
    "data/final_stacks/", fs$daytime, "/", fs$mm, "/",
    fs$odim_code, "_", fs$season, "_thresh_", fs$th, "_avg_", fs$mm, "_", fs$daytime, "_", fs$R_threshold, ".tif"
  )
  if (!dir.exists(dirname(file_out))) dir.create(dirname(file_out), recursive = TRUE)

  if (fs$odim_code == "NLHRW") {
    lat <- 51.8371
    lon <- 5.138
  }
  if (fs$odim_code == "NLDHL") {
    lat <- 52.9528
    lon <- 4.79061
  }

  circle_radius <- 100000 # 100 km in meters

  # Create a simple features (sf) point object
  center_point <- st_sfc(st_point(c(lon, lat)))

  # Buffer the point to create a circular polygon
  st_crs(center_point) <- 4326
  center_point <- st_transform(center_point, crs = st_crs(rmean))
  circle <- st_buffer(center_point, dist = circle_radius)
  masked_raster <- st_rasterize(st_as_sf(circle), st_as_stars(st_bbox(rmean, values = NA_real_), nx = 640, ny = 640))
  masked_raster[masked_raster == 0] <- NA

  raster_masked <- terra::mask(rmean, as(masked_raster, "SpatRaster"))
  clut_masked <- terra::mask(csum, as(masked_raster, "SpatRaster"))

  writeRaster(raster_masked, file_out, overwrite = TRUE)
  writeRaster(clut_masked, paste0(tools::file_path_sans_ext(file_out), "_clut.tif"), overwrite = TRUE)
}
```

## Combine radar, time stacks to national-level maps

We can now combine the radar-level seasonal averages to national-level maps per season. In the overlap zone between both radars, we use max-compositing as this provides the smoothest transition in average `VIR` values between the radars.

```{r}
final_stacks <- expand.grid(
  season = c("spring", "autumn"),
  daytime = c("night"),
  th = c(2500),
  mm = c("scans"),
  zmax = c(750),
  R_threshold = 10
)

fstacks <- asplit(final_stacks, 1)

save_map <- function(x, overwrite = FALSE, cluttermap = FALSE, mode = "dark") {
  fs <- x
  
  basepath_stacks <- "data/final_stacks/"
  if (cluttermap) basepath_stacks <- "data/final_stacks_clutter/"
  basepath_maps <- "data/maps/"
  if (cluttermap) basepath_maps <- "data/maps_clutter/"
  basepath_plots <- "data/maps_plots/VIR_"
  if (cluttermap) basepath_plots <- "data/maps_plots_clutter/VIR_"

  fstacks <- paste0(
    basepath_stacks, fs["daytime"], "/", fs["mm"], "/", c("NLHRW", "NLDHL"), "_",
    fs["season"], "_thresh_", fs["th"], "_avg_", fs["mm"], "_", fs["daytime"], "_", fs["R_threshold"], ".tif"
  )
  fstacks <- str_replace_all(fstacks, " ", "")
  clutstacks <- paste0(tools::file_path_sans_ext(fstacks), "_clut.tif")
  clutstacks <- str_replace_all(clutstacks, " ", "")
  mapfile <- paste0(
    basepath_maps, fs["daytime"], "/", fs["mm"],
    "/NL_", fs["season"], "_", fs["daytime"], "_thresh_", fs["th"], "_avg_", fs["mm"], "_", fs["R_threshold"], ".tif"
  )
  mapfile <- str_replace_all(mapfile, " ", "")

  if (file.exists(mapfile) & !overwrite) {
    return(mapfile)
  }

  if (!dir.exists(dirname(mapfile))) dir.create(dirname(mapfile), recursive = TRUE)

  mapfile_plot <- paste0(
    basepath_plots, fs["zmax"], "/", fs["daytime"], "/", fs["mm"], "/NL_",
    fs["season"], "_", fs["daytime"], "_thresh_", fs["th"], "_avg_", fs["mm"], "_", fs["R_threshold"], ".png"
  )
  mapfile_plot <- str_replace_all(mapfile_plot, " ", "")
  if (!dir.exists(dirname(mapfile_plot))) dir.create(dirname(mapfile_plot), recursive = TRUE)

  r1 <- rast(fstacks[1]) %>% project("EPSG:28992")
  r2 <- rast(fstacks[2]) %>% project("EPSG:28992")

  bbox1 <- ext(r1)
  bbox2 <- ext(r2)

  combined_bbox <- c(min(bbox1$xmin, bbox2$xmin), max(bbox1$xmax, bbox2$xmax), min(bbox1$ymin, bbox2$ymin), max(bbox1$ymax, bbox2$ymax))

  rn <- rast(ext = combined_bbox, crs = "EPSG:28992")
  res(rn) <- 500

  r1_resampled <- resample(r1, rn)
  r2_resampled <- resample(r2, rn)

  m <- mosaic(sprc(r1_resampled, r2_resampled), fun = max)
  writeRaster(m, mapfile, overwrite = TRUE)
  
  r1_clut <- rast(clutstacks[1]) %>% project("EPSG:28992")
  r2_clut <- rast(clutstacks[2]) %>% project("EPSG:28992")

  r1_resampled_clut <- resample(r1_clut, rn)
  r2_resampled_clut <- resample(r2_clut, rn)

  m_clut <- mosaic(sprc(r1_resampled_clut, r2_resampled_clut), fun = max)
  writeRaster(m_clut, paste0(tools::file_path_sans_ext(mapfile), "_clut.tif"), overwrite = TRUE)
  
  maps <- c(m, m_clut)

  data <- raster::as.data.frame(maps, xy = TRUE)

  c <- crs(m)
  nl <- geojsonsf::geojson_sfc("data/gis/Netherlands.geojson") %>% st_transform(c)
  nhol <- geojsonsf::geojson_sfc("data/gis/Noord-Holland.geojson") %>% st_transform(c)
  nhol_buf <- geojsonsf::geojson_sfc("data/gis/Noord-Holland-10km-Buffer.geojson") %>% st_transform(c)
  radar_buf <- geojsonsf::geojson_sf("data/gis/Radars-100km-Buffer.geojson") %>% st_transform(c)

  radar_bbox <- st_bbox(radar_buf)

  padding <- 500
  xlim <- c(radar_bbox$xmin - padding, radar_bbox$xmax + padding)
  ylim <- c(radar_bbox$ymin - padding, radar_bbox$ymax + padding)
  zlim <- c(0, as.numeric(fs["zmax"]))
  tod <- if_else(fs["daytime"] == "night", "by Night", "by Day")
  title <- paste0(str_to_sentence(fs["season"]), " ", tod)
  
  if (mode == "dark") {
    ggplot(data) +
      geom_raster(aes(x = x, y = y, fill = vir_mean / 11)) +
      scale_fill_viridis_c(limits = zlim / 11, name = "Mean\nVID", oob = scales::squish, option = "inferno") +
      geom_sf(data = nl, fill = "NA", color = "white", linewidth = .3) +
      geom_sf(data = radar_buf, fill = "NA", color = "#ffffffaa", linewidth = .3) +
      coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
      ggtitle(title) +
      dark_theme_minimal() +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 14),
        plot.subtitle = element_text(size = 10),
        axis.text = element_text(color = alpha("white", 0.25)),
        panel.grid.major = element_line(color = alpha("white", 0.1)),
        panel.grid.minor = element_line(color = "white"),
        plot.title.position = "plot",
        legend.position = c(1.02, 0.66),
        plot.margin = unit(c(1, 1, 1, 1), "cm")
      ) -> pl1
  } else if (mode == "light") {
    ggplot(data) +
      geom_raster(aes(x = x, y = y, fill = vir_mean / 11)) +
      scale_fill_viridis_c(limits = zlim / 11, name = "Mean\nVID", oob = scales::squish, option = "inferno") +
      geom_sf(data = nl, fill = "NA", color = "black", linewidth = .3) +
      geom_sf(data = radar_buf, fill = "NA", color = "#000000aa", linewidth = .3) +
      coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
      ggtitle(title) +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 14),
        plot.subtitle = element_text(size = 10),
        axis.text = element_text(color = alpha("black", 0.25)),
        panel.grid.major = element_line(color = alpha("black", 0.1)),
        panel.grid.minor = element_line(color = "black"),
        plot.title.position = "plot",
        legend.position = c(1.02, 0.66),
        legend.background = element_rect(fill = "#00000000"),
        plot.margin = unit(c(1, 1, 1, 1), "cm")
      ) -> pl1
  }

  ggsave(mapfile_plot, plot = pl1, width = 5, height = 6)
}

processing <- pbmclapply(fstacks, save_map, overwrite = TRUE, mode = "light", mc.cores = 10, mc.preschedule = FALSE)

saveRDS(processing, paste0("data/logs/processing_mapping_", format(Sys.time(), "%Y%m%dT%H%M"), ".RDS"))
```

# Clutter map creation
Now for the clutter map creation, we follow exactly the same approach up to now, but rather than looking at the migration peaks, we select the scans which supposedly have the least migration.

We start with selecting the lowest 25 scans in terms of nightly migration for each season.

```{r}
vp_mtr %>%
  group_by(year_season, odim_code, day_night) %>%
  filter(top >= tail(top, 25)[1]) %>% 
  identity() -> vp_mtr_low

scantimes <- as_datetime(unlist(apply(vp_mtr_low, MARGIN = 1, FUN = calculate_scantime, simplify = FALSE)))

vp_mtr_low$moment <- scantimes
vp_mtr_low
```
We download the corresponding polar volume files.

```{r}
dts <- dplyr::select(vp_mtr_low, odim_code, moment)

dts_hrw <- dts %>%
  filter(odim_code == "nlhrw") %>%
  pull(moment)

filepaths_hrw <- paste0(
  "minio/pvol/NL/HRW/", year(dts_hrw), "/", sprintf("%02d", month(dts_hrw)), "/", sprintf("%02d", day(dts_hrw)), "/",
  "NLHRW_pvol_", format(dts_hrw, format = "%Y%m%dT%H%M"), "_6356.h5"
)
filepaths_hrw_alt <- paste0(
  "minio/pvol/NL/HRW/", year(dts_hrw), "/", sprintf("%02d", month(dts_hrw)), "/", sprintf("%02d", day(dts_hrw)), "/",
  "NLHRW_pvol_", format(dts_hrw, format = "%Y%m%dT%H%M"), "_NL52.h5"
)
paths <- list(paste0("mc cp ", filepaths_hrw, " ."), paste0("mc cp ", filepaths_hrw_alt, " ."))

write_lines(unlist(paths), file = "data/pvol_clutter/hrw_files.sh", )

dts_dhl <- dts %>%
  filter(odim_code == "nldhl") %>%
  pull(moment)

filepaths_dhl <- paste0(
  "minio/pvol/NL/DHL/", year(dts_dhl), "/", sprintf("%02d", month(dts_dhl)), "/", sprintf("%02d", day(dts_dhl)), "/",
  "NLDHL_pvol_", format(dts_dhl, format = "%Y%m%dT%H%M"), "_6234.h5"
)
filepaths_dhl_alt <- paste0(
  "minio/pvol/NL/DHL/", year(dts_dhl), "/", sprintf("%02d", month(dts_dhl)), "/", sprintf("%02d", day(dts_dhl)), "/",
  "NLDHL_pvol_", format(dts_dhl, format = "%Y%m%dT%H%M"), "_NL51.h5"
)
paths <- list(paste0("mc cp ", filepaths_dhl, " ."), paste0("mc cp ", filepaths_dhl_alt, " ."))

write_lines(unlist(paths), file = "data/pvol_clutter/dhl_files.sh", )
```

And we process the files following the procedure in `rbc_preprocessing.R`. Afterwards, we screen scans again to remove cases with rain, anomalous propagation. We save information on the screening outcomes, to gather files to continue working with.

```{r}
accepted_files <- list.files("data/rbc_png_clutter/full/Accepted/")
rejected_files <- list.files("data/rbc_png_clutter/full/Rejected/")

rbc_file_from_png <- function(file, azim_method = "full") {
  f <- basename(file)
  ss <- str_split(f, "_")[[1]][1:4]
  radar <- str_to_lower(ss[1])
  moment <- parse_date_time(ss[3], "YmdHM")
  fp <- paste0("data/rbc_clutter/", str_c(ss, collapse = "_"), "_", azim_method, ".RDS")
  return(list("odim_code" = radar, "moment" = moment, "rbcfile" = fp))
}

accepted <- bind_rows(lapply(accepted_files, rbc_file_from_png)) %>% mutate(status = "Accepted")
rejected <- bind_rows(lapply(rejected_files, rbc_file_from_png)) %>% mutate(status = "Rejected")

classified_moments <- bind_rows(accepted, rejected)

vp_mtr_low %>%
  left_join(classified_moments, by = join_by(odim_code, moment)) %>%
  mutate(status = replace_na(status, "Rejected")) %>%
  identity() -> vp_mtr_low_cl
```

And again we can make the season-year stacks.

```{r}
g <- expand.grid(year_season = unique(vp_mtr_low_cl$year_season),
                 day_night = unique(vp_mtr_low_cl$day_night),
                 odim_code = unique(vp_mtr_low_cl$odim_code))

generate_stacks <- function(year_season, day_night, odim_code,
                            th = 2500,
                            R_threshold = 10,
                            overwrite = FALSE) {
  
  vp_mtr_low_cl %>%
    filter(status == "Accepted", year_season == !!year_season, day_night == !!day_night, odim_code == !!odim_code) %>%
    drop_na() %>%
    arrange(top) %>%
    dplyr::select(rbcfile, prop) -> files
  
  if (nrow(files) == 0) return("files do not exist")
  
  gr <- expand.grid(th = th, R_threshold = R_threshold, stringsAsFactors = FALSE)
  gr <- asplit(gr, 1)
  
  rbcs <- lapply(files$rbcfile, readRDS)
  lapply(gr, function(x) {stack_rbcs(rbcs = rbcs, year_season = year_season, odimcode = odim_code, 
                                     threshold_max = as.numeric(x["th"]), R_threshold = x["R_threshold"], overwrite = overwrite, clutter_map = TRUE)})
}

processing_stacking <- pbmcmapply(generate_stacks, year_season = g$year_season, day_night = g$day_night, 
                                odim_code = g$odim_code, overwrite = TRUE, mc.cores = 6, mc.preschedule = TRUE)
saveRDS(processing_stacking, paste0("data/logs/processing_stacking_clutter_", format(Sys.time(), "%Y%m%dT%H%M"), ".RDS"))
```

Which now we'll aggregate to to seasonal averages.

```{r}
final_stacks <- expand.grid(
  odim_code = c("NLHRW", "NLDHL"),
  season = c("spring", "autumn"),
  daytime = c("night"),
  th = 2500,
  mm = c("scans"),
  R_threshold = 10
)

for (i in 1:nrow(final_stacks)) {
  fs <- final_stacks[i, ]
  
  rastfiles <- Sys.glob(
    paste0("data/stacks_clutter/", str_to_upper(fs$odim_code), "_*_", fs$season, "_thresh_", fs$th, "_avg_", 
           fs$mm, "_", fs$daytime, "_", fs$R_threshold, ".tif")
  )
  
  stk <- terra::rast(lapply(rastfiles, function(x) {
    tryCatch(terra::rast(x, lyrs = "VIR"), 
             error = function(err) {
               print(err)
             })
  }))
  
  rmean <- app(stk, mean) 
  names(rmean) <- "vir_mean"
  
  stk <- terra::rast(lapply(rastfiles, function(x) {
    tryCatch(terra::rast(x, lyrs = "CLUT"),
      error = function(err) {
        print(err)
      }
    )
  }))
  csum <- app(stk, sum)
  csum <- csum / minmax(csum)[2]
  names(csum) <- "clut_sum"
  
  file_out <- paste0("data/final_stacks_clutter/", fs$daytime, "/", fs$mm, "/", 
                     fs$odim_code, "_", fs$season, "_thresh_", fs$th, "_avg_", fs$mm, "_", fs$daytime, "_", fs$R_threshold, ".tif")
  if (!dir.exists(dirname(file_out))) dir.create(dirname(file_out), recursive = TRUE)
  
  if (fs$odim_code == "NLHRW") {
    lat <- 51.8371
    lon <- 5.138
  }
  if (fs$odim_code == "NLDHL") {
    lat <- 52.9528
    lon <- 4.79061
  }
  
  circle_radius <- 100000  # 100 km in meters

  # Create a simple features (sf) point object
  center_point <- st_sfc(st_point(c(lon, lat)))
  
  # Buffer the point to create a circular polygon
  st_crs(center_point) <- 4326
  center_point <- st_transform(center_point, crs = st_crs(rmean))
  circle <- st_buffer(center_point, dist = circle_radius)
  masked_raster <- st_rasterize(st_as_sf(circle), st_as_stars(st_bbox(rmean, values = NA_real_), nx = 640, ny = 640))
  masked_raster[masked_raster == 0] <- NA
  
  raster_masked <- terra::mask(rmean, as(masked_raster, "SpatRaster"))
  clut_masked <- terra::mask(csum, as(masked_raster, "SpatRaster"))
  
  writeRaster(raster_masked, file_out, overwrite = TRUE)
  writeRaster(clut_masked, paste0(tools::file_path_sans_ext(file_out), "_clut.tif"), overwrite = TRUE)
}
```

And now we convert it into a national-level map of clutter contamination again.

```{r}
final_stacks <- expand.grid(season = c("spring", "autumn"),
                            daytime = c("night"),
                            th = c(2500),
                            mm = c("scans"),
                            zmax = c(2000),
                            R_threshold = 10)

fstacks <- asplit(final_stacks, 1)
processing <- lapply(fstacks, save_map, cluttermap = TRUE, overwrite = TRUE)

saveRDS(processing, paste0("data/logs/processing_mapping_", format(Sys.time(), "%Y%m%dT%H%M"), ".RDS"))
```

# Clutter removal

```{r}
clutter_maps <- expand.grid(season = c("spring", "autumn"),
                            daytime = c("night"),
                            # thresh = c(25, 50, 100, 150, 200, 250, 300),
                            thresh = c(250),
                            # s = c(1, 2, 3, 4, 5, 6, 7),
                            # n = c(13, 17, 21, 25, 29),
                            s = c(4),
                            n = c(25),
                            stringsAsFactors = FALSE)
# clutter_maps <- expand.grid(season = c("spring", "autumn"),
#                             daytime = c("night"),
#                             thresh = c(250),
#                             s = c(4),
#                             n = c(25),
#                             stringsAsFactors = FALSE)

create_final_map_set <- function(map_grid, buffer_patches = NULL,
                                 custom_clutter = NULL) {
  cm <- asplit(map_grid, 1)

  for (m in cm) {
    t <- as.numeric(m["thresh"])
    r <- rast(paste0("data/maps/", m["daytime"], "/scans/NL_", m["season"], "_", m["daytime"],
                     "_thresh_2500_avg_scans_10.tif"))
    if (is.null(custom_clutter)) {
      rc <- rast(paste0("data/maps_clutter/", m["daytime"], "/scans/NL_", m["season"], "_", m["daytime"],
                        "_thresh_2500_avg_scans_10.tif"))
      rc2 <- rast(paste0("data/maps/", m["daytime"], "/scans/NL_", m["season"], "_", m["daytime"],
                        "_thresh_2500_avg_scans_10_clut.tif"))
      print(rc2)
      # Create denoised clutter map
      rc[rc < t] <- NA
      rc[rc >= t] <- 1
      rc2[rc2 > 0.25] <- 1
      rc2[rc2 != 1] <- NA
      rc <- rc | rc2
    } else {
      if (is.logical(custom_clutter)) {
        rc <- rast(paste0("data/final_maps/custom_clutter/NL_", m["season"], "_", m["daytime"], ".tif"))
      } else if (is.character(custom_clutter)) {
        rc <- rast(custom_clutter)
      }
    }
    
    s <- as.numeric(m["s"])
    n <- as.numeric(m["n"])
    
    # Prepare GIS data for plots
    c <- crs(r)
    nl <- geojsonsf::geojson_sfc("data/gis/Netherlands.geojson") %>% st_transform(c)
    nhol <- geojsonsf::geojson_sfc("data/gis/Noord-Holland.geojson") %>% st_transform(c)
    nhol_buf <- geojsonsf::geojson_sfc("data/gis/Noord-Holland-10km-Buffer.geojson") %>% st_transform(c)
    radar_buf <- geojsonsf::geojson_sf("data/gis/Radars-100km-Buffer.geojson") %>% st_transform(c)
    
    prc <- patches(rc)
    zrc <- zonal(cellSize(prc, unit = "km"), prc, sum, as.raster = TRUE)
    src <- ifel(zrc < 0.5, NA, prc)
    rcn <- rc
    rcn[is.na(src)] <-NA
    
    if (!is.null(buffer_patches)) {
      rcn <- buffer(rcn, width = buffer_patches)
      rcn <- rcn * 1
      rcn[rcn == 0] <- NA
    }
    
    cluts <- c(rc, rcn)
    cls <- as.data.frame(cluts, xy = TRUE)
    colnames(cls) <- c("x", "y", "clut_orig", "clut_denoised")
    cls %>% pivot_longer(cols = -c(x, y), names_to = "clut_type") %>% drop_na() -> cls
    ggplot() +
      geom_raster(aes(x = x, y = y, fill = clut_type, group = clut_type), data = cls) +
      facet_wrap(~clut_type) +
      dark_theme_minimal() +
      geom_sf(data = nl, fill = "NA", color = "white", linewidth = .3) +
      geom_sf(data = nhol, fill = "NA", color = "white", linewidth = .3) +
      geom_sf(data = radar_buf, fill = "NA", color = "white", linewidth = .3) +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            plot.title = element_text(size = 14),
            plot.subtitle = element_text(size = 10),
            axis.text = element_text(color = alpha("white", 0.25)),
            panel.grid.major = element_line(color = alpha("white", 0.1)),
            panel.grid.minor = element_line(color = "white"),
            plot.title.position = "plot",
            plot.margin = unit(c(1,1,1,1), "cm")) -> pclut
    
    # Save plot
    fp_clutplot <- paste0("data/final_maps/NL_", m["season"], "_", m["daytime"], 
                          "_thresh_", t, "_s_", s, "_n_", n, "_clut.png")
    ggsave(pclut, width = 7, height = 4, filename = fp_clutplot)
    
    # Save clutter map
    fp_clut <- paste0("data/final_maps/NL_", m["season"], "_", m["daytime"], 
                      "_thresh_", t, "_s_", s, "_n_", n, "_clutter.tif")
    writeRaster(rcn, fp_clut, overwrite = TRUE)
    
    # Create final bird map
    rn <- r
    rn[rcn == 1] <- NA
    
    # Blur
    suppressMessages({
      b <- raster.gaussian.smooth(rn, s=s, n=n, na.rm = TRUE, type = "mean")
    })
    
    # Remove area introduced by blur
    b[is.na(r)] <- NA
    
    # Save bird map
    fp_bird <- paste0("data/final_maps/NL_", m["season"], "_", m["daytime"], 
                      "_thresh_", t, "_s_", s, "_n_", n, ".tif")
    writeRaster(b, fp_bird, overwrite = TRUE)
    
    # Plots for quick overviews
    if (m["season"] == "autumn") {
      zlims <- c(0, 800)
    } else if (m["season"] == "spring") {
      zlims <- c(0, 800)
    }
    
    data <- as.data.frame(b, xy = TRUE)
    clut <- as.data.frame(rcn, xy = TRUE)
    
    ggplot() +
      geom_raster(aes(x = x, y = y, fill = focal_mean), data = data) +
      scale_fill_viridis_c(limits = zlims, oob = scales::squish, option = "inferno", na.value = 0, name = "Mean VIR") +
      new_scale_fill() +
      geom_raster(data = clut, aes(x = x, y = y), fill = alpha("black", 0.4)) +
      geom_sf(data = nl, fill = "NA", color = "white", linewidth = .3) +
      geom_sf(data = nhol, fill = "NA", color = "white", linewidth = .3) +
      geom_sf(data = radar_buf, fill = "NA", color = "white", linewidth = .3) +
      dark_theme_minimal() +
      labs(title = paste0(str_to_sentence(m["season"]), " by ", m["daytime"])) +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            plot.title = element_text(size = 14),
            plot.subtitle = element_text(size = 10),
            # axis.text.x = element_text(color = "white"),
            # axis.text.y = element_text(color = "white"),
            axis.text = element_text(color = alpha("white", 0.25)),
            panel.grid.major = element_line(color = alpha("white", 0.1)),
            panel.grid.minor = element_line(color = "white"),
            plot.title.position = "plot",
            plot.margin = unit(c(1,1,1,1), "cm"))-> p
    
    # Save plot
    fp_plot <- paste0("data/final_maps/NL_", m["season"], "_", m["daytime"], 
                      "_thresh_", t, "_s_", s, "_n_", n, ".png")
    ggsave(p, filename = fp_plot)
    
    # Log
    print(m)
  }
}

create_final_map_set(clutter_maps, buffer_patches = 500)
```

After a visual inspection of the plots above created with a grid of settings (see commented out), we have settled on using clutter maps with a VIR threshold of 250.

# Beam blockage

After calculating beam blockage using "beam-blockage/beamblockage.ipynb", which can also be found in [the wradlib package documentation](https://docs.wradlib.org/en/1.19.1/notebooks/beamblockage/wradlib_beamblock.html), two .csv's storing x,y,z and CBB (cumulative beam blockage) values are created for both HRW and DHL radars. We will turn these in raster files which can be used in this project.

```{r}
hrw_bb <- read_csv("data/beam_blockage/hrw.csv", col_types = "dddddd") %>% 
  dplyr::select(x, y, CBB)

dhl_bb <- read_csv("data/beam_blockage/dhl.csv", col_types = "dddddd") %>%
  dplyr::select(x, y, CBB)

exrast_hrw <- rast("data/final_stacks/night/scans/NLHRW_autumn_thresh_2500_avg_scans_night_10.tif")
exrast_dhl <- rast("data/final_stacks/night/scans/NLDHL_autumn_thresh_2500_avg_scans_night_10.tif")

v_hrw <- vect(hrw_bb, geom = c("x", "y"), crs = "epsg:4326") %>% project(exrast_hrw)
v_dhl <- vect(dhl_bb, geom = c("x", "y"), crs = "epsg:4326") %>% project(exrast_dhl)

cbb_hrw <- rasterize(v_hrw, exrast_hrw, field = "CBB", fun = max) %>%
  focal(w = c(5, 5), fun = "max", na.rm = TRUE)
cbb_dhl <- rasterize(v_dhl, exrast_dhl, field = "CBB", fun = max) %>%
  focal(w = c(5, 5), fun = "max", na.rm = TRUE)
writeRaster(cbb_hrw, "data/beam_blockage/hrw.tif", overwrite = TRUE)
writeRaster(cbb_dhl, "data/beam_blockage/dhl.tif", overwrite = TRUE)

plot(cbb_hrw)
plot(cbb_dhl)

clip_to_radius <- function(raster_full, odim_code, radius) {
  if (odim_code == "NLHRW") {
    lat <- 51.8371
    lon <- 5.138
  }
  if (odim_code == "NLDHL") {
    lat <- 52.9528
    lon <- 4.79061
  }
  
  circle_radius <- radius  # 100 km in meters

  # Create a simple features (sf) point object
  center_point <- st_sfc(st_point(c(lon, lat)))
  
  # Buffer the point to create a circular polygon
  st_crs(center_point) <- 4326
  center_point <- st_transform(center_point, crs = st_crs(raster_full))
  circle <- st_buffer(center_point, dist = circle_radius)
  # mask(x = raster_data, mask = circle)  
  masked_raster <- st_rasterize(st_as_sf(circle), st_as_stars(st_bbox(raster_full, values = NA_real_), nx = 640, ny = 640))
  masked_raster[masked_raster == 0] <- NA
  
  raster_masked <- terra::mask(raster_full, as(masked_raster, "SpatRaster"))
  raster_masked
}

r1 <- cbb_hrw %>% clip_to_radius("NLHRW", 100000) %>% project("EPSG:28992")
r2 <- cbb_dhl %>% clip_to_radius("NLDHL", 100000) %>% project("EPSG:28992")

bbox1 <- ext(r1)
bbox2 <- ext(r2)

combined_bbox <- c(min(bbox1$xmin, bbox2$xmin), max(bbox1$xmax, bbox2$xmax), 
                   min(bbox1$ymin, bbox2$ymin), max(bbox1$ymax, bbox2$ymax))

rn <- rast(ext = combined_bbox, crs = "EPSG:28992")
res(rn) <- 500

r1_resampled <- resample(r1, rn)
r2_resampled <- resample(r2, rn)

m <- mosaic(sprc(r1_resampled, r2_resampled), fun = "last") # DHL should be last!
m[m == 0] <- NA
plot(m)
writeRaster(m, "data/beam_blockage/NL_beamblockage.tif", overwrite = TRUE)
```
# Quantifying seasonal cumulative migration
We use the vertical profiles to quantify how many birds actually pass over the Netherlands seasonally.

```{r}
vp_grid <- expand_grid(
  radar = c("HRW", "DHL"),
  year = c(2017:2023),
  month = c(2, 3, 4, 5, 8, 9, 10, 11)
)

vpfiles_to_vpts <- function(radar, year, month) {
  # print(paste0("data/vp/", radar, "/", year, "/", sprintf("%02d", month), "/*/*.h5"))
  rds_out <- paste0("data/vpts/", radar, year, sprintf("%02d", as.numeric(month)), ".RDS")
  if(file.exists(rds_out)) {
    print(paste0(rds_out, " exists"))
    return(rds_out)
  }
  vpfiles <- Sys.glob(paste0("data/vp/", radar, "/", year, "/", sprintf("%02d", as.numeric(month)), "/*/*.h5"))
  if (length(vpfiles) == 0) {
    return(paste0(rds_out, " skipped, no vpfiles"))
  }
  vps <- pbmclapply(vpfiles, function(x) {
    vp <- bioRad:::read_vp(x)
    vp
  }, mc.cores = 8)
  vps <- vps[!sapply(vps, is.null)] # Remove nulls
  vps <- do.call(bioRad:::c.vp, vps)
  
  vpts <- bind_into_vpts(vps)
  vpts <- regularize_vpts(vpts)
  sd_vvp_threshold(vpts) <- 2
  
  saveRDS(vpts, rds_out)
  print(paste0(rds_out, " processed"))
  return(rds_out)
}

out <- apply(vp_grid, 1, function(x) vpfiles_to_vpts(x[1], x[2], x[3]))

vptsfiles_to_mt <- function(radar, year) {
  year_vpts <- Sys.glob(paste0("data/vpts/", radar, year, "*.RDS"))
  
  year_vpts <- lapply(year_vpts, readRDS)
  year_vpts <- do.call(bind_into_vpts, year_vpts)
  # year_vpts <- regularize_vpts(year_vpts)
  
  spring_period <- c(paste0(year, "-02-15 00:00"), paste0(year, "-05-31 23:55"))
  autumn_period <- c(paste0(year, "-08-15 00:00"), paste0(year, "-11-30 23:55"))
  
  spring_vpts <- regularize_vpts(filter_vpts(year_vpts, spring_period[[1]], spring_period[[2]], night = TRUE), 
                                 date_min = as.POSIXct(spring_period[[1]]), date_max = as.POSIXct(spring_period[[2]]),
                                 interval = 300, fill = 3600)
  saveRDS(spring_vpts, paste0("data/vpts_seasonal/", radar, year, "_spring.RDS"))
  autumn_vpts <- regularize_vpts(filter_vpts(year_vpts, autumn_period[[1]], autumn_period[[2]], night = TRUE), 
                                 date_min = as.POSIXct(autumn_period[[1]]), date_max = as.POSIXct(autumn_period[[2]]),
                                 interval = 300, fill = 3600)
  saveRDS(autumn_vpts, paste0("data/vpts_seasonal/", radar, year, "_autumn.RDS"))
  spring_vpi <- integrate_profile(spring_vpts)
  autumn_vpi <- integrate_profile(autumn_vpts)
  
  cum_mt <- list("radar" = radar, "year" = year, "spring_mt" = max(spring_vpi$mt, na.rm = TRUE), "autumn_mt" = max(autumn_vpi$mt, na.rm = TRUE))
  return(cum_mt)
}

vpts_grid <- expand_grid(
  radar = c("HRW", "DHL"),
  year = c(2017:2023)
)

cum_mts <- pbmclapply(asplit(vpts_grid, 1), function(x) vptsfiles_to_mt(x[1], x[2]), mc.cores = 5)
saveRDS(cum_mts, "data/vpts/cum_mts.RDS")

cum_mts <- bind_rows(cum_mts) %>%
  pivot_longer(cols = c(spring_mt, autumn_mt), names_to = "season", values_to = "mt") %>%
  mutate(season = case_match(
    season,
    "autumn_mt" ~ "autumn",
    "spring_mt" ~ "spring"
  )) %>%
  filter(!(season == "spring" & year == 2017) & !(season == "autumn" & year == 2023))

cummts
```
And now we calculate averages from both radars combined for both spring and autumn.

```{r}
cummts %>%
  group_by(season) %>%
  summarise(mt_mean = mean(mt)) %>%
  arrange(season) %>%
  identity() -> mig_averages

cummts %>%
  group_by(season, radar) %>%
  summarise(mt_mean = mean(mt)) %>%
  arrange(radar, season) %>%
  identity() -> mig_averages_radar

print(mig_averages)
print(mig_averages_radar)
```

# Final maps

With all that data in place, we can start to compile the figures. The altitude profile figures — Figure 1 — are in the radar-profiles.Rmd file.

## Figure data prep

```{r}
ban <- rast("data/final_maps/NL_autumn_night_thresh_250_s_4_n_25.tif")
bsn <- rast("data/final_maps/NL_spring_night_thresh_250_s_4_n_25.tif")

ban <- ban / global(ban, mean, na.rm = TRUE)[[1]]
bsn <- bsn / global(bsn, mean, na.rm = TRUE)[[1]]

ban <- ban * mig_averages$mt_mean[[1]]
bsn <- bsn * mig_averages$mt_mean[[2]]

c <- st_crs(ban)
nl <- geojsonsf::geojson_sf("data/gis/Netherlands.geojson") %>% st_transform(c)
nl_buf <- geojsonsf::geojson_sfc("data/gis/Netherlands-5km-Buffer.geojson") %>% st_transform(c)
clut_buf <- rast("data/final_maps/NL_autumn_night_thresh_250_s_4_n_25_clutter.tif") %>%
  as.polygons() %>%
  st_as_sf() %>%
  st_transform(c)
clut_man <- geojsonsf::geojson_sf("data/gis/manual_clutter.geojson") %>% st_transform(c) %>% filter(id < 5)

bb <- rast("data/beam_blockage/NL_beamblockage.tif")
bb[bb < 0.05] <- NA
bb <- bb %>%
  as.polygons() %>%
  simplifyGeom(1000) %>%
  fillHoles() %>%
  st_as_sf() %>%
  st_transform(c)
bb$pattern <- "stripe"
nhol <- geojsonsf::geojson_sfc("data/gis/Noord-Holland.geojson") %>% st_transform(c)
nhol_buf <- geojsonsf::geojson_sfc("data/gis/Noord-Holland-10km-Buffer.geojson") %>% st_transform(c)
nhol_bbox <- st_bbox(nhol_buf)
radar_buf <- geojsonsf::geojson_sf("data/gis/Radars-100km-Buffer.geojson") %>% st_transform(c)
radars <- geojsonsf::geojson_sf("data/gis/Radars.geojson") %>% st_transform(c) %>% filter(acronym != "artis")

gebieden <- geojsonsf::geojson_sf("data/gis/gemeenten.geojson") %>% st_transform(c) %>% 
  filter(Gemeentenaam %in% c("Amsterdam", "Diemen")) %>%
  rename(gebied = Gemeentenaam) %>%
  dplyr::select(gebied, geometry) %>%
  bind_rows(nhol %>% st_as_sf() %>% rename(geometry = x) %>% mutate(gebied = "Noord-Holland")) %>%
  bind_rows(nl %>% mutate(gebied = "Nederland") %>% dplyr::select(gebied, geometry))

bbc <- st_geometry(bb) %>% st_intersection(st_geometry(nl_buf))
clut_bufc <- st_geometry(clut_buf) %>% st_intersection(st_geometry(nl_buf))
clut_manc <- st_geometry(clut_man) %>% st_intersection(st_geometry(nl_buf))
uncertainty <- spatialEco::sf_dissolve(st_as_sf(st_union(st_union(bbc, clut_bufc), clut_manc)))
uncertainty$certainty <- "Clutter affected"

res_all <- st_read("data/gis/RES/RES_zoekgebieden_Actueel.shp") %>%
  filter(str_detect(`Type_`, 'Wind') | str_detect(`Type_`, 'wind')) %>% 
  st_transform(c)
res_all %>%
  sf:::select.sf(RES_id, Naam_gebie, Type_, Regio, RES_deel_r) %>%
  st_difference(clut_bufc) %>%  # Remove areas in clutter contaminated zone
  mutate(Naam_gebie = str_replace(Naam_gebie, "\\d+[a-z]\\) ", ""),
         ID = row_number()) %>%
  identity() -> res

ban_extract <- extract(ban, vect(res), raw = TRUE) %>% as.data.frame() %>% rename(MT_autumn = focal_mean)
bsn_extract <- extract(bsn, vect(res), raw = TRUE) %>% as.data.frame() %>% rename(MT_spring = focal_mean)

nhol_average_ban <- extract(ban, vect(nhol), raw = TRUE) %>% as.data.frame() %>% summarise(avg = mean(focal_mean, na.rm = TRUE))
nhol_average_bsn <- extract(bsn, vect(nhol), raw = TRUE) %>% as.data.frame() %>% summarise(avg = mean(focal_mean, na.rm = TRUE))
```

## Figure 2: Overview maps of the Netherlands

```{r message=FALSE, warning=FALSE}
nl_buf_spatvector <- vect(nl_buf)

ban <- terra::mask(ban, nl_buf_spatvector)
bsn <- terra::mask(bsn, nl_buf_spatvector)

map_to_df <- function(map, s, d, z) {
  as.data.frame(map, xy = TRUE) %>%
    rename("mt_mean" = "focal_mean") %>%
    mutate(mt_mean = mt_mean / 1000,
           season = s,
           daytime = d,
           zlim = z)
}

data <- mapply(map_to_df, map = list(ban, bsn), 
               s = c("Autumn", "Spring"), 
               d = c("night", "night"),
               z = c(800, 800),
               SIMPLIFY = FALSE) %>%
  bind_rows()
  
data %>%
  # filter(daytime == "night", season == "Autumn") %>%
  ggplot() +
  geom_sf(data = nl, fill = "NA", color = alpha("black", 0.5), linewidth = .3) +
  geom_raster(aes(x = x, y = y, fill = mt_mean)) +
  scale_fill_viridis_c(limits = c(0, 900), oob = scales::squish, option = "inferno", na.value = 0,
                       name = expression(atop("Migration traffic", "\u00D7" ~ 1000 ~ "birds" %.% "km"^-1))) +
  theme_void(base_size = 14) +
  geom_sf(data = nl_buf, fill = "NA", color = alpha("white", 0.9), linewidth = 2) +
  geom_sf(data = st_union(radar_buf), fill = "NA", color = alpha("white", 0.9), linewidth = 2) +
  geom_sf(data = nl, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  # geom_sf(data = nl_buf, fill = "NA", color = "white", linewidth = .3) +
  geom_sf(data = nhol, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  geom_sf(data = radar_buf, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  # geom_sf(data = uncertainty %>% st_intersection(radar_buf %>% st_buffer(-1000)) %>% st_intersection(nl_buf), fill = "#00000025", 
  #         color = alpha("white", 0.3), linewidth = .3) +
  geom_sf_pattern(aes(pattern = certainty),
                  data = uncertainty %>% st_intersection(st_union(radar_buf) %>% st_buffer(-1000)) %>% st_intersection(nl_buf),
                  fill = alpha("black", 0.15), color = alpha("black", 0.15),
                  pattern_density = 0.3, pattern_spacing = 0.005, pattern_fill = alpha("black", 0.1), pattern_color = NA) +
  geom_sf(data = radars, color = alpha("white", 0.5), size = 3) +
  scale_pattern_manual(values = "stripe", name = "Clutter affected") +
  coord_sf(expand = FALSE) +
  facet_wrap(~fct_relevel(season, "Spring", "Autumn")) +
  annotation_scale(text_col = "black", style = "ticks", line_col = "black") +
  theme(panel.spacing.x = unit(0, "lines"))
ggsave("data/final_maps_plots/maps.pdf", width = 17, height = 10, device = cairo_pdf)
```

## Figure 3a: Overview map of North-Holland

```{r message=FALSE, warning=FALSE}
nhol_bbox_expanded <- nhol_bbox
padding <- -5000
nhol_bbox_expanded["xmin"] <- nhol_bbox_expanded["xmin"] - padding - 20000
nhol_bbox_expanded["xmax"] <- nhol_bbox_expanded["xmax"] + padding
nhol_bbox_expanded["ymin"] <- nhol_bbox_expanded["ymin"] - padding
nhol_bbox_expanded["ymax"] <- nhol_bbox_expanded["ymax"] + padding + 30000

pol_bbox <- st_as_sf(st_as_sfc(st_bbox(nhol_bbox_expanded)))
pol_nhol <- nhol_buf

nhol_outside_mask <- st_difference(pol_bbox, pol_nhol)

data %>%
  filter(daytime == "night", season == "Autumn") %>%
  ggplot() +
  geom_sf(data = nl, fill = "NA", color = alpha("black", 0.5), linewidth = .3) +
  geom_raster(aes(x = x, y = y, fill = mt_mean)) +
  scale_fill_viridis_c(limits = c(0, 900), oob = scales::squish, option = "inferno", na.value = 0,
                       name = expression(atop("Migration traffic", "\u00D7" ~ 1000 ~ "birds" %.% "km"^-1))) +
  theme_void(base_size = 14) +
  geom_sf(data = nl_buf, fill = "NA", color = alpha("white", 1), linewidth = 4) +
  geom_sf(data = st_union(radar_buf), fill = "NA", color = alpha("white", 0.9), linewidth = 2) +
  geom_sf(data = nl, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  # geom_sf(data = nl_buf, fill = "NA", color = "white", linewidth = .3) +
  geom_sf(data = nhol, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  geom_sf(data = radar_buf, fill = "NA", color = alpha("white", 0.3), linewidth = .3) +
  # geom_sf(data = uncertainty %>% st_intersection(radar_buf %>% st_buffer(-1000)) %>% st_intersection(nl_buf), fill = "#00000025", 
  #         color = alpha("white", 0.3), linewidth = .3) +
  # geom_sf_pattern(aes(pattern = certainty),
  #                 data = uncertainty %>% st_intersection(radar_buf %>% st_buffer(-1000)) %>% st_intersection(nl_buf),
  #                 fill = alpha("white", 0.15), color = alpha("black", 0.1),
  #                 pattern_density = 0.025, pattern_spacing = 0.01, pattern_fill = alpha("black", 0.1), show.legend = TRUE) +
  geom_sf_pattern(aes(pattern = certainty),
                  data = uncertainty %>% st_intersection(st_union(radar_buf) %>% st_buffer(-1000)) %>% st_intersection(nl_buf),
                  fill = alpha("black", 0.15), color = alpha("black", 0.15),
                  pattern_density = 0.3, pattern_spacing = 0.01, pattern_fill = alpha("black", 0.1), pattern_color = NA,
                  show.legend = TRUE) +
  geom_sf(data = radars, color = alpha("white", 0.5), size = 2.5) +
  new_scale_fill() +
  new_scale_color() +
  geom_sf(data = res, aes(fill = "Candidate sites", color = "Candidate sites"), linewidth = 0.3, show.legend = TRUE) +
  scale_fill_manual(values = alpha("yellow", 0.5), name = "Candidate sites") +
  scale_color_manual(values = alpha("black", 0.75), name = "Candidate sites") +
  scale_pattern_manual(values = "stripe", name = "Clutter affected") +
  # geom_sf(data = nhol_outside_mask, fill = alpha("black", 0.6), color = NA) +
  coord_sf(xlim = c(nhol_bbox_expanded["xmin"], nhol_bbox_expanded["xmax"]),
           ylim = c(nhol_bbox_expanded["ymin"], nhol_bbox_expanded["ymax"]),
           expand = FALSE) +
  # facet_wrap(~fct_relevel(season, "Spring", "Autumn")) +
  annotation_scale(text_col = "black", style = "ticks", line_col = "black") +
  theme(panel.margin.x = unit(0, "lines"))

ggsave("data/final_maps_plots/northholland.pdf", width = 8, height = 10, device = cairo_pdf)
```

## Figure 3b: Migration across candidate sites

```{r}
ban_extract %>%
  cbind(bsn_extract %>% dplyr::select(MT_spring)) %>%
  left_join(res, by = "ID") %>%
  arrange(desc(MT_autumn)) %>%
  mutate(Naam_gebie = case_match(Naam_gebie,
                                "Knooppunt Holendrecht" ~ "Holendrecht",
                                "Diemen Wind B" ~ "Diemen B",
                                "Diemen Wind C" ~ "Diemen C",
                                "IJburg Diemerpark" ~ "IJburg Diemerp.",
                                "Zeeburgereiland" ~ "Zeeburgereil.",
                                "Havengebied West" ~ "Havengeb. West",
                                "Zuiderlegmeerpolder-oost" ~ "Zuiderlegmeerp.",
                                "Kade Velsen Noord" ~ "Velsen Noord",
                                "ten noorden ring A10 - westelijk gebied" ~ "Ring A10 Noord",
                                "Zon en wind in  Noordzeekanaalgebied" ~ "Z&W Noordzknl.",
                                .default = Naam_gebie),
         Naam_gebie = as.factor(Naam_gebie),
         Naam_gebie = fct_reorder(Naam_gebie, MT_autumn),
         geometry_x = st_coordinates(st_centroid(geometry))[,1],
         geometry_y = st_coordinates(st_centroid(geometry))[,2]) %>%
  group_by(Naam_gebie) %>%
  mutate(MT_mean_autumn = mean(MT_autumn),
         MT_mean_spring = mean(MT_spring)) %>%
  ungroup() %>%
  group_by(RES_deel_r) %>%
  mutate(mean_x = mean(geometry_x),
         mean_y = mean(geometry_y),
         RES_deel_r = as.factor(RES_deel_r),
         RES_deel_r = fct_reorder(RES_deel_r, mean_y, .desc = FALSE),
         RES_deel_r = recode(RES_deel_r,
                             "Regio Alkmaar" = "Alkmaar",
                             "West-Friesland" = "West-Friesland",
                             "IJmond-Zuid Kennemerland" = "IJmond/\nZuid-Kennemerland",
                             "Zaanstreek-Waterland" = "Zaanstreek/\nWaterland",
                             "Amsterdam" = "Amsterdam",
                             "Amstelland" = "Amstelland",
                             "Haarlemmermeer" = "Haarlemmermeer")) %>%
  ungroup() %>%
  identity() -> res_summaries

key <- key_range_manual(start = c(min(res_summaries$MT_spring) / 1000, min(res_summaries$MT_autumn) / 1000),
                        end = c(max(res_summaries$MT_spring) / 1000, max(res_summaries$MT_autumn) / 1000),
                        name = c("Spring", "Autumn"))

res_summaries %>%
  ggplot() +
  geom_vline(color = "#00000030", xintercept = nhol_average_ban[[1]] / 1000) +
  geom_vline(color = "#00000030", xintercept = nhol_average_bsn[[1]] / 1000) +
  ggdist::stat_pointinterval(aes(x = MT_autumn / 1000, y = Naam_gebie, color = MT_mean_autumn / 1000), .width = c(1, .5)) +
  ggdist::stat_pointinterval(aes(x = MT_spring / 1000, y = Naam_gebie, color = MT_mean_spring / 1000), .width = c(1, .5)) +
  scale_color_viridis_c(name = "birds/km", option = "inferno", end = 0.85, breaks = c(200, 400, 600, 800), limits = c(150, 800)) +
  scale_y_discrete(breaks = levels(res_summaries$Naam_gebie)[seq(1, length(levels(res_summaries$Naam_gebie)), by = 2)]) +
  guides(x.sec = guide_axis_nested(key = key, bracket = "square"),
         color = guide_colorbar(title = expression(atop("Migration traffic", "\u00D7" ~ 1000 ~ "birds" %.% "km"^-1)),
                                direction = "vertical",
                                barwidth = 1.2,
                                barheight = 10,
                                position = "inside",
                                draw.ulim = TRUE)) +
  theme_minimal(base_size = 14) +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.title.x = element_text(hjust = 1),
        legend.direction = "vertical",
        legend.background = element_rect(fill = "white", colour = NA),
        legend.position = "right",
        legend.position.inside = c(0.85, 0.3),
        legend.title = element_text(hjust = 0),
        legend.key.width = unit(0.7, "inches"),
        legend.key.height = unit(0.2, "inches")) +
  labs(# title = "Seasonal migration traffic",
       # subtitle = "across candidate sites for wind energy in the province of North-Holland",
       x = expression("\u00D7" ~ 1000 ~ "birds" %.% "km"^-1),
       y = "Candidate site") +
  coord_cartesian(xlim = c(150, 825), expand = FALSE)
ggsave(filename = "data/final_maps_plots/candidatesites.pdf", width = 8, height = 6)
```

# Statistics

Surface area of maps

```{r}
ar <- cellSize(ban, mask = TRUE)
covered_by_map <- global(ar, sum, na.rm = TRUE) / 1000000  # m2 to km2

# And as a proportion of the Netherlands
surface_nl <- 41540
covered_by_map / surface_nl
```
Nights with pulses identified

```{r}
vp_mtr_cum50 %>%
  distinct(date_trunc) %>%
  identity() %>%
  nrow()

# And per season
vp_mtr_cum50 %>% 
  group_by(season) %>% 
  distinct(date_trunc) %>%
  summarise(n_per_season = n())

# And averages per season
vp_mtr_cum50 %>%
  group_by(year, season) %>%
  distinct(date_trunc) %>%
  summarise(n_per_season = n()) %>%
  group_by(season) %>%
  dplyr::select(season, n_per_season) %>%
  skim()
```

Nights per season

```{r}
vp_mtr %>%
  filter(day_night == "night") %>%
  group_by(season, year, odim_code) %>%
  summarise(nights_per_season = n()) %>%
  group_by(season) %>%
  summarise(nights_per_season_max = max(nights_per_season))
```



```{r}
res_summaries %>%
  filter(Naam_gebie != "Landelijk Noord") %>%
  add_count(Naam_gebie) %>%
  mutate(above_average = if_else(MT_mean_autumn >= nhol_average_ban[[1]], "yes", "no"),
         above_90 = if_else(MT_mean_autumn >= quantile(MT_mean_autumn, .9), "yes", "no")) %>%
  group_by(above_average) %>%
  summarise(size = sum(n))
```

```{r}
cv <- function(data) { sd(data) / mean(data) * 100}

cv_spring <- cv(res_summaries$MT_spring)
cv_autumn <- cv(res_summaries$MT_autumn)
print(c(cv_spring, cv_autumn))
```
